
To support the features we wanted to include in this game while staying true to the goals we wanted to achieve, we decided to use Apple’s own IDE, XCode, in order to develop this program. XCode fully supports Swift and frameworks such as SpriteKit. Specifically, SpriteKit comes with multiple pre-written capabilities, allowing us to reference a library of commands to execute our vision. SpriteKit was the framework used to implement almost all of our actions, objects, etc. Every time you see “SK___”, it means that we are using SpriteKit to help us perform an action, texture, node, etc. Specifically, when we declare all our movement variables under the GameScene class, each of our variables are defined as SpriteKit nodes, Sprites, textures, or actions.

Further, world physics (e.g. gravity) is an essential aspect of this game as the poo needs to fall downward if the player stops tapping the screen, ultimately hitting the floor and ending the game. We needed to fully understand Swift’s documentation for applying physics to objects in the GameScene. Some examples of implementing physics in our project were defining the physics bodies that exist through a struct called PhysicsCategory. Anytime we needed to refer to the body of an object, “.physicsBody” was used. For example, when we defined that the downTube was not a dynamic element, our line of code was: downTube.physicsBody?.isDynamic = false. Additionally, detecting contact between the Poo and any other object needed a “contact delegation” in which we defined using SKPhysicsContactDelegate under the class “GameScene”. 

To implement buttons (Start and Reset button), we relied on the Internet to look for examples of buttons and how they were implemented. We realized that for each button, we needed to create entire new Swift files and connect them to our GameScene (similar to how CSS files are connected to HTML files). In our buttons Swift files, we defined the function of the button, as well as any visual user-interface design points (e.g. making the button semi-transparent while it was selected). 

To ensure that our game’s design was optimal and to make it easier to troubleshoot for bugs, our entire “didSceneLoad” functionality was to ensure that our scene loaded correctly and connections to other Swift files existed. This ensured that our button nodes and scroll nodes were connected.

To scroll through the world indefinitely, we had to add movement to the pipes, ground, and clouds. Technically, the Poo never moves horizontally due to user input, rather the objects move to the left to give the effect that the Poo is moving forward. As a result, we needed to code horizontal movement for all objects except for the Poo. The cloudScroll and scrollWorld functions code the leftward movement of the clouds and ground. Because this game does not have a definite ending, we had to efficiently code a way for the clouds, ground, and pipes to spawn indefinitely instead of hard-coding in the entire pathway (which would be very impractical and inefficient because we’d eventually reach the end of the game). We decided that once the clouds/ground left the screen, we would reposition the cloud/ground sprites to be on the other side of the screen to then move leftward across the screen again, and again, and again! Using this logic, our program turned out to be quite efficient.

Other smaller design decisions also took a lot of trial and error. For example, in earlier implementations of our program, we noticed that the different pipe pairs were incredibly close together, so we experimented with the spawn time delay in order to increase the horizontal distance between the pairs of new pipes. In addition, after testing our program, it was evident that the space or “gap” between the pipes, vertically, was too large. Playing around with our variable “pipeGap” also allowed us to increase the difficulty and enhance the visual design of our game.

Ultimately, we decided to implement our program in XCode primarily because it’s an IDE that allows for greater ease in observing visual components; especially when designing an app, this aspect allows more features to be testable. It also allows the programmer to "build" a program, meaning that the interactive and visual aspects of the code can be tested in a simulator, making it extremely valuable for beginner coders when learning how to implement their program. All in all, this was an enriching and fun challenge that we were able to undertake!
